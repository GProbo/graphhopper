<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <link rel="stylesheet" href="./node_modules/codemirror/lib/codemirror.css"/>
    <link rel="stylesheet" href="./style.css"/>
    <link rel="stylesheet" href="./node_modules/codemirror/addon/hint/show-hint.css"/>
    <script src="./node_modules/codemirror/lib/codemirror.js"></script>
    <script src="./node_modules/codemirror/mode/yaml/yaml.js"></script>
    <script src="./node_modules/codemirror/addon/hint/show-hint.js"></script>
</head>
<body>
<textarea
        id="textbox"
        rows="50"
        cols="100"
        style="width: 500px; height: 400px"
>
    </textarea>
<h1>custom errors</h1>
<ol id="errors"></ol>
<h1>condition errors</h1>
<ol id="condition-errors"></ol>

<script type="module">
    import {validate} from "./validate.js";
    import {complete} from "./complete.js";
    import {parse} from "./parse.js";

    const conditionRangeMarks = [];
    const yamlErrorMarks = [];
    const textbox = document.querySelector("#textbox");
    const cm = CodeMirror.fromTextArea(textbox, {
        lineNumbers: true,
        mode: "yaml",
        extraKeys: {
            'Ctrl-Space': showHints
        }
    });

    const categories = {
        "max_speed": ["<number>"].sort(),
        "road_class": ["OTHER", "MOTORWAY", "TRUNK", "PRIMARY", "SECONDARY", "TERTIARY", "RESIDENTIAL", "UNCLASSIFIED", "SERVICE", "ROAD", "TRACK", "BRIDLEWAY", "STEPS", "CYCLEWAY", "PATH", "LIVING_STREET", "FOOTWAY", "PEDESTRIAN", "PLATFORM", "CORRIDOR"].sort(),
        // todo: need actual boolean encoded values, but currently only supporting string values!
        "road_class_link": ["true", "false"].sort(),
        "road_environment": ["OTHER", "ROAD", "FERRY", "TUNNEL", "BRIDGE", "FORD", "SHUTTLE_TRAIN"].sort(),
        "road_access": ["YES", "DESTINATION", "CUSTOMERS", "DELIVERY", "FORESTRY", "AGRICULTURAL", "PRIVATE", "OTHER", "NO"].sort(),
        "surface": ["MISSING", "PAVED", "ASPHALT", "CONCRETE", "PAVING_STONES", "COBBLESTONE", "UNPAVED", "COMPACTED", "FINE_GRAVEL", "GRAVEL", "GROUND", "DIRT", "GRASS", "SAND", "OTHER"].sort(),
        "toll": ["NO", "ALL", "HGV"].sort()
    };

    cm.on("cursorActivity", (e) => {
        // in case the auto-complete popup is active already we update it (allow filtering values while typing with
        // an open popup)
        if (cm.state.completionActive) {
            showHints();
        }
        conditionRangeMarks.forEach((m) => m.clear());
        yamlErrorMarks.forEach((m) => m.clear());
        const validateResult = validate(cm.getValue());

        const errors = validateResult.errors;
        const errorList = document.querySelector("#errors");
        displayList(errorList, errors.map(e => `${e.path}: ${e.message}`));

        const conditionErrors = validateResult.conditionRanges
            .map(cr => {
                const condition = cm.getValue().substring(cr[0], cr[1]);
                const p = parse(condition, categories);
                const location = condition.slice(p.range[0], p.range[1]);
                if (p.error === null)
                    return '';
                else
                    return `${p.error} at ${location}, suggestion: ${parse(condition, categories).completions}`;
            })
            .filter(c => c.length > 0);

        const conditionList = document.querySelector("#condition-errors");
        displayList(conditionList, conditionErrors);

        // highlight text area where conditions were entered and errors in condition
        const conditionRanges = validateResult.conditionRanges;
        conditionRanges.forEach((cr, i) => {
            const from = cm.posFromIndex(cr[0]);
            const to = cm.posFromIndex(cr[1]);
            conditionRangeMarks.push(cm.markText(from, to, {
                className: 'gh-condition'
            }));
            const condition = cm.getValue().substring(cr[0], cr[1]);
            const parseRes = parse(condition, categories);
            if (parseRes.error !== null) {
                conditionRangeMarks.push(cm.markText(
                    cm.posFromIndex(cr[0] + parseRes.range[0]),
                    cm.posFromIndex(cr[0] + parseRes.range[1]), {
                        className: 'gh-condition-error'
                    }));
            }
        });
        // highlight errors in yaml
        // todo: add tooltip with error message
        validateResult.errors.forEach((err, i) => {
            const range = err.range;
            if (range !== null) {
                yamlErrorMarks.push(cm.markText(
                    cm.posFromIndex(range[0]), cm.posFromIndex(range[1]), {
                        className: 'gh-yaml-error'
                    }
                ));
            }
        })

    });

    function showHints() {
        const validateResult = validate(cm.getValue());
        const cursor = cm.indexFromPos(cm.getCursor());
        validateResult.conditionRanges
            .map(cr => {
                const condition = cm.getValue().substring(cr[0], cr[1]);
                const offset = cr[0];
                // todo: do not run this if cursor is outside of condition!
                // but note that we allow the cursor being at the end (inclusive!) of the range, is this ok?!
                if (cursor >= offset && cursor <= cr[1]) {
                    const completeRes = complete(condition, cursor - offset, categories);
                    if (completeRes.suggestions.length > 0) {
                        const range = [
                            cm.posFromIndex(completeRes.range[0] + offset),
                            cm.posFromIndex(completeRes.range[1] + offset),
                        ];
                        showHint(range, completeRes.suggestions);
                    }
                }
            });
    }

    function showHint(range, suggestions) {
        const options = {
            hint: function () {
                const completion = {
                    from: range[0],
                    to: range[1],
                    list: suggestions,
                };
                CodeMirror.on(completion, "pick", function (selectedItem) {
                    // console.log(selectedItem);
                });
                return completion;
            },
        };
        cm.showHint(options);
    }

    function displayList(list, items) {
        while (list.firstChild)
            list.removeChild(list.firstChild);
        for (let error of items) {
            const listElement = document.createElement("li");
            listElement.textContent = error;
            list.appendChild(listElement);
        }
    }
</script>
</body>
</html>
