<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <link rel="stylesheet" href="./node_modules/codemirror/lib/codemirror.css"/>
    <link rel="stylesheet" href="./style.css"/>
    <link rel="stylesheet" href="./node_modules/codemirror/addon/hint/show-hint.css"/>
    <script src="./node_modules/codemirror/lib/codemirror.js"></script>
    <script src="./node_modules/codemirror/addon/hint/show-hint.js"></script>
    <script src="./node_modules/codemirror/mode/yaml/yaml.js"></script>
    <!-- todo: include via npm -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv/7.1.0/ajv7.min.js"
            integrity="sha512-DkKbsp/6j5EoCy0115sD8kzmVQwngxax5doaQO0IuO55n+sytVhLokgZvnIi1+cDUiN1nARtsQ6h7iq9tgOY8g=="
            crossorigin="anonymous"></script>
</head>
<body>
<textarea
        id="textbox"
        rows="50"
        cols="100"
        style="width: 500px; height: 400px"
>
    </textarea>
<h1>custom errors</h1>
<ol id="errors"></ol>
<h1>json schema validation</h1>
<ol id="json-schema-errors"></ol>
<h1>condition</h1>
<ol id="condition-errors"></ol>

<script type="module">
    import * as YAML from './node_modules/yaml/browser/dist/index.js';
    import {validate} from "./validate.js";
    import {complete} from "./complete.js";
    import {parse} from "./parse.js";

    const Ajv = window.ajv7.default
    const ajv = new Ajv({allErrors: true});

    const conditionRangeMarks = [];
    fetch('custom_model_schema.json')
        .then((s) => s.json())
        .then((schema) => {
            const ajvValidate = ajv.compile(schema);
            const textbox = document.querySelector("#textbox");
            const cm = CodeMirror.fromTextArea(textbox, {
                lineNumbers: true,
                mode: "yaml",
            });
            cm.on("cursorActivity", (e) => {
                conditionRangeMarks.forEach((m) => m.clear());
                const validateResult = validate(cm.getValue());

                const errors = validateResult.errors;
                const errorList = document.querySelector("#errors");
                displayList(errorList, errors);

                const categories = {
                    "max_speed": ["<number>"],
                    "road_class": ["OTHER", "MOTORWAY", "TRUNK", "PRIMARY", "SECONDARY", "TERTIARY", "RESIDENTIAL", "UNCLASSIFIED", "SERVICE", "ROAD", "TRACK", "BRIDLEWAY", "STEPS", "CYCLEWAY", "PATH", "LIVING_STREET", "FOOTWAY", "PEDESTRIAN", "PLATFORM", "CORRIDOR"],
                    // todo: need actual boolean encoded values, but currently only supporting string values!
                    "road_class_link": ["true", "false"],
                    "road_environment": ["OTHER", "ROAD", "FERRY", "TUNNEL", "BRIDGE", "FORD", "SHUTTLE_TRAIN"],
                    "road_access": ["YES", "DESTINATION", "CUSTOMERS", "DELIVERY", "FORESTRY", "AGRICULTURAL", "PRIVATE", "OTHER", "NO"],
                    "surface": ["MISSING", "PAVED", "ASPHALT", "CONCRETE", "PAVING_STONES", "COBBLESTONE", "UNPAVED", "COMPACTED", "FINE_GRAVEL", "GRAVEL", "GROUND", "DIRT", "GRASS", "SAND", "OTHER"],
                    "toll": ["NO", "ALL", "HGV"]
                };
                const cursor = cm.indexFromPos(cm.getCursor());
                const conditionErrors = validateResult.conditions
                    .map((c, i) => {
                        const offset = validateResult.conditionRanges[i][0];
                        let suggestions = [];
                        // todo: do not run this if cursor is outside of condition!
                        // but note that we allow the cursor being at the end (inclusive!) of the range, is this ok?!
                        if (cursor >= offset && cursor <= validateResult.conditionRanges[i][1]) {
                            const completeRes = complete(c, cursor - offset, categories);
                            if (completeRes.suggestions.length > 0) {
                                const options = {
                                    hint: function () {
                                        return {
                                            from: cm.posFromIndex(completeRes.range[0] + offset),
                                            to: cm.posFromIndex(completeRes.range[1] + offset),
                                            list: completeRes.suggestions,
                                            // without this we cannot backspace e.g. surface, but is this better?
                                            completeSingle: false
                                        };
                                    },
                                };
                                cm.showHint(options);
                            }
                            suggestions = completeRes.suggestions;
                        }
                        const p = parse(c, categories);
                        const location = c.slice(p.range[0], p.range[1]);
                        if (p.error === null) return '';
                        else return `${p.error} at ${location}, suggestion: ${parse(c, categories).completions}, autocomplete: ${suggestions}`;
                    })
                    .filter(c => c.length > 0);
                const conditionList = document.querySelector("#condition-errors");
                displayList(conditionList, conditionErrors);

                // highlight text area where conditions were entered and errors in condition
                const conditionRanges = validateResult.conditionRanges;
                conditionRanges.forEach((cr, i) => {
                    const from = cm.posFromIndex(cr[0]);
                    const to = cm.posFromIndex(cr[1]);
                    conditionRangeMarks.push(cm.markText(from, to, {
                        className: 'gh-condition'
                    }));
                    const parseRes = parse(validateResult.conditions[i], categories);
                    if (parseRes.error !== null) {
                        conditionRangeMarks.push(cm.markText(
                            cm.posFromIndex(cr[0] + parseRes.range[0]),
                            cm.posFromIndex(cr[0] + parseRes.range[1]), {
                                className: 'gh-condition-error'
                            }));
                    }
                });

                const jsonSchemaErrorList = document.querySelector("#json-schema-errors");
                const doc = YAML.parseDocument(cm.getValue()).toJS();
                const valid = ajvValidate(doc);
                if (valid)
                    displayList(jsonSchemaErrorList, [])
                else {
                    // todo: we could use the 'dataPath' to further customize/improve our error messages
                    // also we could use json-source-maps to retrieve line number information (maybe): https://github.com/ajv-validator/ajv/issues/763#issuecomment-590566870
                    // but we would still have to do custom checks for things we cannot cover by json schema so not really sure
                    // this is better...
                    let displayErrors = ajvValidate.errors.map(e => `${e.dataPath}: ${e.message}`);
                    displayList(jsonSchemaErrorList, displayErrors);
                }
            });
        });

    function displayList(list, items) {
        while (list.firstChild)
            list.removeChild(list.firstChild);
        for (let error of items) {
            const listElement = document.createElement("li");
            listElement.textContent = error;
            list.appendChild(listElement);
        }
    }
</script>
</body>
</html>
